ifndef::imagesdir[:imagesdir: ../images]

[[section-quality-scenarios]]
== QualitÃ¤tsanforderungen
=== QualitÃ¤tstools

.Um die QualitÃ¤t des Codes sicherzustellen werden folgende Tools verwendet:
* Checkstyle: Liefert statische Code Analyse.
* JaCoCo: Wertet die Code Coverage der Tests aus.
* SonarQube: Inspiziert Code QualitÃ¤t und kann neben Code Smells und Bugs auch Duplizierten Code, Standarts und weitere Empfehlungen machen. Die Auswertung nach technischen Schulden liefert eine gute Metrik Ã¼ber Aufwand zur Verbesserung.
* SonarLint: Ein Plugin von Sonar, welches direkt in der IDE bereits Reports zur QualitÃ¤t des Codes erstellen kann.
* (SpotBugs)

Viele der genannten Tools konnten aus ZeitgrÃ¼nden leider nur teilweise oder nicht wie geplant eingesetzt werden. Am besten sind solche Tools in der CI/CD Pipeline anzusetzten, sodass diese gezwungenermassen eingsetzt werden mÃ¼ssen.

Wir haben im Projekt einen SonarQube Server aufgesetzt. Jedoch haben wir es nicht geschafft, die Pipeline zu modifizieren, sodass der SonarQube Server direkt als Gate verwendet werden kann. Deshalb hier ein Auszug via Printscreen:

image::SonarQube.png[SonarQube]

https://sonar.g04.swda.hslu-edu.ch[G04 Sonar Qube Instanz]

Die Daten haben wir erhalten, indem mit Maven die Analyse lokal ausgefÃ¼hrt wurde und danach hochgeladen wurde.

[source]
mvn clean verify sonar:sonar \
-Dsonar.projectKey=hslu_edu_bachelor-computer-science_swda_24fs01_g04_g04-inventory-service_149cb96d-67ce-4561-9d54-7c3264102427 \
-Dsonar.projectName='g04-inventory-service' \
-Dsonar.host.url=https://sonar.g04.swda.hslu-edu.ch \
-Dsonar.token=TOKEN_FUER_SONARQUBE

*Auswertung SonarQube*

Wie erwartet hat SonarQube sofort die oben genannten Credentials im Mail-Service erkannt. Entsprechend hat der Mail-Service ein Security Rating vom Wert D erhalten. Mithilfe eines Vaults kÃ¶nnte das verbessert werden.

image::SonarQube_Password.png[SonarQube_Password]


=== Testing
==== Teststrategie
Es wird auf Unit-, Integrations- und Systemtests gesetzt. Die Unit- und Integrationstests sind automatisiert, wÃ¤hrend die
Systemtests manuell durchgefÃ¼hrt werden. FÃ¼r die Tests werden verschiedene Technologien eingesetzt, so werden JUNIT, EqualsVerifier und
Mockito fÃ¼r die Unit Tests verwendet. ZusÃ¤tzlich werden TestContainer und Unirest fÃ¼r die Integrationstests genutzt. Systemtests
werden mit Swagger ui oder Postman durchgefÃ¼hrt. DarÃ¼ber hinaus werden Logs und Seiten wie z.B. MongoViewer benÃ¶tigt, um ein
genaueres Bild der AnwendungsablÃ¤ufe zu erhalten.
Die folgende Abbildung gibt einen guten Einblick wie eine API getestet werden kann.


image::API_testing_types.png[Entity-Relationship Diagramm Log und Mappers]


Von den aufgelisteten Testvarianten werden Smoke Testing, Functional Testing, Integration Testing und Regression Testing
durchgefÃ¼hrt. Diese helfen wÃ¤hrend der Entwicklung die Sicherheit zu haben, dass der hinzugefÃ¼gte Code den Anforderungen entspricht.
Load-, Stress-, Security-, UI- und Fuzz-Testing werden nicht durchgefÃ¼hrt. Dies bedeutet, dass das System nur auf korrekte
und nicht Ã¼bermÃ¤ssige Nutzung getestet wird. WÃ¤re geplant, das System in Betrieb zu nehmen, mÃ¼ssten diese Tests zusÃ¤tzlich
durchgefÃ¼hrt werden.

*Entwicklungsvorgehen:* Wir bauten die Microservices nach der 3 Schichtenarchitekur auf. Die Reihenfolge des Aufbaus dieser Schichten
hat einen grossen Einfluss auf die Integrations-Tests. Denn ein "bottom up" Ansatz, bei welchem sich zuerst um die Datenbank und zuletzt um
die Persentation Schicht gekÃ¼mmert wird kann verheerend fÃ¼r die Integration-Tests sein. Denn beim Bau von unten nach oben werden die unteren Schichten
meist mitgetestet. Die Tests sollten aber mÃ¶glichst isoliert sein. Darum wurde als Teil der Teststrategie festgehalten und auch so umgesetzt, dass
zuerst die Rest-API aufgebaut wird, dann das Messaging und erst zum Schluss die Datenbank eingerichtet wird.


==== Testdokumentation
===== Testprotokoll (manuelle Systemtests)

[cols="1,3,3,3,3,15"]
|===
| Nr. | Datum | Tester | Version | Status | (Fehler-)Beschreibung

| I | 20.05 | Gian | e107daa2 | ğŸŸ¢
| Preis wird nicht gespeichert.

|===


.Legende 1: Teststatus
* ğŸŸ¢ Erfolgreich
* ğŸŸ  Teilweise erfolgreich/fehlgeschlagen -> Status auch wenn Lokal erfolgreich jedoch Prod nicht (deployt).
* ğŸ”´ Fehlgeschlagen


====== Testszenario I : Bestellung abfragen (1d, 4a)
.Voraussetzungen
* Benutzer erfasst
* Bestellung(en) erfasst

.Ablauf / Schritte
* **/orders** aufrufen
* **/orders/{no}** mit einer Bestellnummer aus orders aufrufen

.Erwartetes Resultat
* **/orders** liefert alle erfassten Bestellungen zurÃ¼ck
* **/orders/{no}** liefert die entsprechende Bestellung zurÃ¼ck
* In einer Bestellung sind die Bestellnummer (Random), Kunde (E-Mail), VerkÃ¤ufer (E-Mail), Liefer- & Rechnungsadresse, Positionen (bestehend aus Menge und Artikelnummer), Datum/Uhrzeit, **Preis** und ein Bestellstatus vorhanden.

====== Testszenario X : Rechnung erstellen (1g)

====== Testszenario X : Ausstehende Rechnung / Mahnung (1f)
